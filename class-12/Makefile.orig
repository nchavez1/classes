
# For Maryland, FIPS = 24
FIPS=24
FILE1=cb_2014_$(FIPS)_tract_500k
FILE2=cb_2014_$(FIPS)_tract_B01003

# Download and convert cenus-tract polygons
tracts.json: node_modules/shapefile
	curl 'https://www2.census.gov/geo/tiger/GENZ2014/shp/$(FILE1).zip' -o $(FILE1).zip
	# unzip the archive
	unzip -o $(FILE1).zip
	# convert to GeoJSON (also reads dbf file and adds feature.properties to the GeoJSON
	node_modules/shapefile/bin/shp2json $(FILE1).shp -o $@

# Download population from API (https://www.census.gov/developers/)
#  In this case, B01003_001 denotes total population estimate, "for" & "in" denote sampling
#  For detail, see API docs: https://www.census.gov/data/developers/data-sets/acs-5year.html
$(FILE2).json:
	curl 'https://api.census.gov/data/2014/acs5?get=B01003_001E&for=tract:*&in=state:'$(FIPS) -o $@


# Project using NAD83 / Maryland (EPSG:26985) -- from d3-stateplane
projected.json: tracts.json
	node_modules/d3-geo-projection/bin/geoproject \
	  'd3.geoConicConformal().parallels([38 + 18 / 60, 39 + 27 / 60]).rotate([77, -37 - 40 / 60]).fitSize([960, 500], d)' \
	  < $^ > $@

projected.svg: projected.json
	node_modules/d3-geo-projection/bin/geo2svg -w 960 -h 500 < $^ > $@

# Convert JSON to newline-delimited stream of features (one per line) with ndjson-split
projected.ndjson: projected.json
	node_modules/ndjson-cli/ndjson-split 'd.features' < $^ > $@

# Convert ndjson so that each feature has a unique id that will be used to join population data
# Note: To see what's going on, use "| more" instead of redirecting stdout to a file
projected-id.ndjson: projected.ndjson
	node_modules/ndjson-cli/ndjson-map 'd.id = d.properties.GEOID.slice(2), d' \
	  < $^ > $@

# Convert population estimates (data come in as JSON array) to ndjson stream
#   1. ndjson-cat removes newlines
#   2. ndjson-split separates array into multiple lines
#   3. ndjson-map reformats each line as an object
#   4. Optionally pipe output to json2csv to create a CSV file
$(FILE2).ndjson: $(FILE2).json
	node_modules/ndjson-cli/ndjson-cat $^ \
	| node_modules/ndjson-cli/ndjson-split 'd.slice(1)' \
	| node_modules/ndjson-cli/ndjson-map   '{id: d[2] + d[3], B01003: +d[0]}' \
	> $@

# Join the population data to the census-tract geometry with ndjson-join
projected-join.ndjson: projected-id.ndjson $(FILE2).ndjson
	node_modules/ndjson-cli/ndjson-join "d.id" $^ > $@

# Compute population density (and remove properties that are no longer needed) with ndjson-map
# Note: 2589975.2356 = 1609.34^2 converts land area from square meters to square miles
projected-density.ndjson: projected-join.ndjson
	node_modules/ndjson-cli/ndjson-map \
	  'd[0].properties = {density: Math.floor(d[1].B01003 / d[0].properties.ALAND * 2589975.2356)}, d[0]' \
	  < $^ > $@

# Convert back to GeoJSON (in case you want to stop here and visualize the data in a browser)
projected-density.json: projected-density.ndjson
	node_modules/.bin/ndjson-reduce < $^ \
	| node_modules/.bin/ndjson-map '{type: "FeatureCollection", features: d}' > $@

# Add a "fill" property
#     1. Require d3 with "-r d3"
projected-color.ndjson: projected-density.ndjson
	node_modules/ndjson-cli/ndjson-map -r d3 \
	  '(d.properties.fill = d3.scaleSequential(d3.interpolateViridis).domain([0, 4000]) (d.properties.density), d)' \
	  < $^ > $@

# Create an SVG chloropleth
projected-color.svg: projected-color.ndjson
	node_modules/d3-geo-projection/bin/geo2svg -n --stroke none -p 1 -w 960 -h 500 \
	  < $^ > $@

# Convert to topojson
#   -n   output is ndjson (one line per feature)
#   tracts=projected-density.ndjson   specify a named GeoJSON input (i.e., "layer")
tracts-topo.json: projected-density.ndjson
	node_modules/.bin/geo2topo -n \
	  tracts=$^ \
	  > $@

# Simplify topojson
#  -p 1   use planar area threshold of 1 square pixel for Visvalingham's method  (ok since we're equal area)
#  -s     would use this before projection instead to specify steridian threshold
#  -f     remove small, detached rings (little islands)
simple-topo.json: tracts-topo.json
	node_modules/.bin/toposimplify -p 1 -f < $^ > $@

# Quantize and delta encode topology
#  See: https://github.com/topojson/topojson-client/blob/master/README.md#topoquantize
quantized-topo.json: simple-topo.json
	node_modules/.bin/topoquantize 1e5 < $^ > $@

# Create county boundaries, which compose hierarchically from census tracts
#  -k  defines key expression used to group features from "tracts" object (similar to nest.key in d3-collection)
#      this adds a new "counties" object in the output topology
merge-topo.json: simple-topo.json
	node_modules/.bin/topomerge -k "d.id.slice(0,3)" counties=tracts < $^ > $@

# Keep only internal county borders (don't need to stroke external boundaries)
topo.json: merge-topo.json
	node_modules/.bin/topomerge --mesh -f 'a !== b' counties=counties < $^ > $@

clean:
	-rm $(FILE1).*
	-rm *.ndjson
	-rm cb*
	-rm merge-topo.json
	-rm projected.json
	-rm simple-topo.json
	-rm tracts-topo.json
	-rm tracts.json
	-rm -r node_modules
